<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.537">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Zion Gassner">
<meta name="dcterms.date" content="2024-01-28">

<title>Zion’s Extraordinary Python Adventure - Getting Your Favorite Movies: Using Scrapy to Crawl through the Web</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Zion’s Extraordinary Python Adventure</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About Zion’s Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Getting Your Favorite Movies: Using Scrapy to Crawl through the Web</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">week 4</div>
                <div class="quarto-category">homework 2</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Zion Gassner </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 28, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>It’s natural to be interested in works created by certain artists, and movies are no exception–if there’s an actor or actress that you’re a fan of, there’s a good chance that you’ll like the other films that they’ve appeared in. There are websites, like https://www.themoviedb.org, that conveniently arrange all of that information, but it can be tedious for a human being to have to go through it page by page.</p>
<p>The internet, though, is made up of computers, and as such, has a structure to it that we can manipulate using computers. In particular, webpages are often designed with HTML–the ML of which means “markup language.” This means that websites are usually sorted into organized pieces of information that contain different markers, called tags, that signal what they’re used for. HTML tags are of the form <code>&lt;tag&gt; ... &lt;/tag&gt;</code>, where the information within the dots could be text, link, other tags, or much more things.</p>
<p>By using a technique called <em>web scraping</em>, we can sift through web pages to search for specific tags and grab whatever information we want. To do this, we’re going to use a framework called <code>scrapy</code> that’s written in Python, but we won’t really be using a <code>jupyter</code> notebook as we have been previous. Rather, we’ll be editing files directly that use Python syntax but have a <em>lot</em> of machinery under the hood. The purpose of this post is not to meticulously detail every aspect of <code>scrapy</code>–I would have no idea how to do that–but rather to introduce some of its web scraping capabilities so that you can carry out something like this yourself.</p>
<p>We are going to be scraping the aforementioned website https://www.themoviedb.org, but before we get to that, let’s go over how to set up <code>scrapy</code>.</p>
</section>
<section id="getting-started" class="level1">
<h1>Getting Started</h1>
<p>Setting up a <code>scrapy</code> project is something that you’ll have to do through the command line. I am using Anaconda on a Mac and am using an environment provided for me by my PIC 16B professor that automatically comes with <code>scrapy</code>. For details on any other preliminary steps that may be necessary for your system, please see the following links:</p>
<p>Installation: https://docs.scrapy.org/en/latest/intro/install.html</p>
<p>Setup: https://docs.scrapy.org/en/latest/intro/tutorial.html</p>
<section id="creating-the-project" class="level2">
<h2 class="anchored" data-anchor-id="creating-the-project">Creating the Project</h2>
<p>Every <code>scrapy</code> project starts as some sort of folder on your system, but we have the choice of what directory we’d like to place that folder in. Because I’m putting my project together with my Quarto blog, I navigated to the folder to this post to create my project. To do so, use the following syntax:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> <span class="st">"folder name"</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> <span class="st">"final folder name"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That is, each time you call <code>cd</code> and specify a folder name, you will change your current directory to that folder. If you want to place your project into a folder within a folder, you must call <code>cd</code> multiple times, each time specifying the name of a folder you’d like to navigate to.</p>
<p>Then, to generate a (blank) <code>scrapy</code> project, enter the following commands:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate <span class="st">"environment name"</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">scrapy</span> startproject <span class="st">"project name"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Replace <code>environment name</code> with whatever Anaconda environment has <code>scrapy</code> installed. This is necessary for us to run the command after, which will create the project, giving it whatever name you specify where I have written <code>project name</code>. In my case, the commands looked like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate PIC16B-24W</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">scrapy</span> startproject TMDB_scraper</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This will create a folder with the name <code>TMDB_scraper</code> which contains everything we need for the web scraper. It is absolutely essential that you then change your working directory to the project folder, otherwise, your scraper won’t work!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> TMDB_scraper</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="creating-the-scraper" class="level2">
<h2 class="anchored" data-anchor-id="creating-the-scraper">Creating the Scraper</h2>
<p>Now, within Finder (or Explorer for Windows), open the newly created <code>TMDB_scraper</code> folder. You should see the following: 1. A file called <code>scrapy.cfg</code> 2. Another folder also with the name <code>TMDB_scraper</code></p>
<p>We’ll return to <code>scrapy.cfg</code> in a bit–it contains some more general configurations for how <code>scrapy</code> works on our system. For now, though, open <code>TMDB_scraper</code>.</p>
<p>Inside of this folder, you should see something like the following:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img1.png" class="img-fluid figure-img"></p>
<figcaption>Image 1</figcaption>
</figure>
</div>
<p>We will be returning to <code>settings.py</code> later. The other <code>.py</code> files are not going to be explored for the purposes of this exercise, but more advanced web-scraping projects will require you to edit them.</p>
<p>For now, open the folder called <code>spiders</code>. This is where we will manipulate our spider–which we can think of a little “device” that we set up to crawl through our website. It’s what does the scraping for us, and it’s where we’ll have to do most of the coding.</p>
<p>You will be greeted by a file called <code>__init__.py</code>. Open it using the program of your choice. I always use Xcode.</p>
<p>This should file should be blank besides a comment that is generated by default. Please paste the following into the file (generated by Professor Ko). Below, I’ll explain what the code means, and how we’re going to use it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># to run </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># scrapy crawl tmdb_spider -o movies.csv -a subdir=137113-edge-of-tomorrow</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scrapy</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TmdbSpider(scrapy.Spider):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> <span class="st">'tmdb_spider'</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, subdir<span class="op">=</span><span class="va">None</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start_urls <span class="op">=</span> [<span class="ss">f"https://www.themoviedb.org/movie/</span><span class="sc">{</span>subdir<span class="sc">}</span><span class="ss">/"</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(<span class="va">self</span>, response):</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="va">None</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="va">None</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>parse</code>, <code>parse_full_credits</code>, and <code>parse_actor_page</code> yield <code>None</code> as a placeholder. We’ll add to the bodies of these functions later.</p>
<p>Since our environment already has <code>scrapy</code>, we should be able to import it without any issue.</p>
<p>First of all, note that we have to declare a class in order for our spider to exist. The name of the class can be whatever you want, but here, I name it <code>TmdbSpider</code>. The class only takes one input, namely, <code>scrapy.Spider</code>. In the body of the class, we define a class variable called <code>name</code>, which will determine the name of the spider which we will use when calling it in the command line, so make sure to give it a name that makes sense! Here, I use <code>tmdb_spider</code>.</p>
<p>Then, for the initialization, besides the mandatory parameter <code>self</code> (recall from PIC16A), we include the argument <code>subdir</code> which by default, we set to <code>None</code> and also allow for additional arguments. We will pass arguments into the spider via the command line. Within the initialization, we have to declare an instance variable called <code>start_urls</code> which is a list of one string, in our case. The element of this list determines what site our spider will start on. I say start on, because by crawling through a website, it can effectively “click” on other links on the page. Here, we declare an f string that takes us to the page of a given movie on themoviedb website. After <code>/movie/</code>, each film has its own unique extension which is precisely what the argument <code>subdir</code> determines. My favorite movie is the action film Edge of Tomorrow starring Tom Cruise, so we’ll be using that for the purposes of this blog. You can pick whatever movie you’d like, but make sure to use the appropriate <code>subdir</code>.</p>
<p>A method specifically named <code>parse</code> is required in order for our spider to work. Before we get to that, though, it’s important to understand on a conceptual level what we want our spider to do:</p>
</section>
<section id="website-navigation" class="level2">
<h2 class="anchored" data-anchor-id="website-navigation">Website Navigation</h2>
<p>Recall that our overall goal is to grab the names of all movies that the actors in a given movie appear in. Let’s take a look at our movie’s page to see how this works:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img2.png" class="img-fluid figure-img"></p>
<figcaption>Image 2</figcaption>
</figure>
</div>
<p>The text circled in red, “Full Cast &amp; Crew”, is actually a link that will take us to a page that lists all of the people credited in the movie with the following URL:</p>
<p>https://www.themoviedb.org/movie/137113-edge-of-tomorrow/cast</p>
<p>Notice that this is nearly identical to the previous link except with <code>/cast</code> added to the end. Here’s what the page looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img3.png" class="img-fluid figure-img"></p>
<figcaption>Image 3</figcaption>
</figure>
</div>
<p>Then, if we click on an actor or actress’s name, we’re taken to a page with a somewhat different directory. In the case of Tom Cruise, we have:</p>
<p>https://www.themoviedb.org/person/500-tom-cruise</p>
<p>If we scroll down on the page, we see that we have a list of movies that Cruise has been in:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img4.png" class="img-fluid figure-img"></p>
<figcaption>Image 4</figcaption>
</figure>
</div>
<p>Clicking on the name of the movie will in fact take you to the corresponding page about the movie, but we’re not interested in that. Once we get to this page, we just want to grab the names of the movies, and then repeat this process for the other actors.</p>
</section>
<section id="specifications" class="level2">
<h2 class="anchored" data-anchor-id="specifications">Specifications</h2>
<p>Before giving an outline of what we want our spider to do, we should clarify what we want the final output to be. It would be convenient for us to return a <code>.csv</code> file containing each actor’s name and the name of the movie they’ve been in for each entry. The part where we generate the <code>.csv</code> will actually be done in the command line for us–all we need to do with our spider is to generate a dictionary that corresponds to the entries, where the keys are the name of the columns. Hence, we’ll want one for the actor’s name, and one for the name of the movie.</p>
<p>Okay, let’s inspect the HTML source code of our pages. Note that we’ll start with the “cast” page since all we need to do to get here from the movie page is just by adding <code>cast</code> to the URL. Thus, we won’t actually need to have the spider interact with the movie page itself.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img5.png" class="img-fluid figure-img"></p>
<figcaption>Image 5</figcaption>
</figure>
</div>
<p>Okay, what’s going on here? Remember, tags in HTML are always enclosed in something like <code>&lt;tag&gt;...&lt;/tag&gt;</code>, and a webpage will usually nest lots of tags inside of each other.</p>
<p>We see that there is an <code>&lt;ol&gt;</code> tag–which stands for ordered list–of class <code>people credits</code>. <code>&lt;ol&gt;</code> is a tag built into HTML, whereas <code>people credits</code> is just one class of <code>ol</code> among others that exist on the website. If you see on the left-hand side, we can access this with <code>ol.people.credits</code>. Now, just letting you know ahead of time, we can essentially make our spider retrieve content that exists under certain headings, which is why we want to keep track of what sort of tags and classes are relevant for us.</p>
<p>Then, within the <code>&lt;ol&gt;</code>, we see that we have a bunch of <code>&lt;li&gt;</code> tags, which stands for list item. Let’s look in more detail at the first one (which is opened up in the above image).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img6.png" class="img-fluid figure-img"></p>
<figcaption>Image 6</figcaption>
</figure>
</div>
<p>Everything between the underlined <code>&lt;li&gt;</code> and <code>&lt;/li&gt;</code> is contained within the list element. We see that there are several tags within. One type is called <code>&lt;div&gt;</code>, which stands for division. This divides <code>&lt;li&gt;</code> into different sections. There is another tag called <code>&lt;a&gt;</code>, which contains a link. See how there’s two different ones? The one at the top, which has a <code>&lt;div&gt;</code> tag within it, is a link embedded into the photo of Tom Cruise. The other one is a link embedded into the text that shows his name (highlighted on the left-hand side of the screen).</p>
<p>We can see what page the link takes us to by looking at the <code>href</code> <strong>attribute</strong> of the <code>&lt;a&gt;</code> tag. You can imagine this to be like a sort of “class variable” for <code>&lt;a&gt;</code>. <code>href</code> actually shows what page the link will take us to. In our case, we see that, in both cases, we get taken to the same page: <code>/person/500-tom-cruise/</code>. Note that this is a subdirectory that we’d have to append onto our URL.</p>
<p>Though both links take us to the same page, we’ll be using the second instance for two reasons. One, it contains less information within it (no images), and two, we can also grab the name of the actor. See how after the <code>href</code> link we simply see the text <code>Tom Cruise</code>? We can grab the actor name from there.</p>
<p>Now, let’s see what we need from the actor page:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Hw2Img7.png" class="img-fluid figure-img"></p>
<figcaption>Image 7</figcaption>
</figure>
</div>
<p>So, what do we see here? There’s a <code>&lt;section&gt;</code> of class <code>full_wrapper_credits</code>. This will contain the different movies that the actor has been cast in. Within <code>full_wrapper_credits</code> is a <code>&lt;div&gt;</code> of class <code>credits_list</code>. On each actor’s page, though, it doesn’t just show what movie’s they’ve acted in, but also, what movie’s they’ve produced or have been a non-acting crew member in. We see this in that within <code>div.credits.list</code> are different <code>&lt;tables&gt;</code> of class <code>card credits</code>. The one at the very top is unlabeled and contains the movies they’ve acted in, but if we see below, there are others with an <code>&lt;h3&gt;</code> (header 3) text entry right before, “Production” and “Crew”.</p>
<p>That means that we have to be careful! We don’t want to select a movie if our favorite actor didn’t actually play in it. Let’s look inside of the table now:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img8.png" class="img-fluid figure-img"></p>
<figcaption>Image 8</figcaption>
</figure>
</div>
<p>Similarly to the <code>&lt;ol&gt;</code>, the table is filled with instances of <code>&lt;tr&gt;</code>–table rows. Each <code>&lt;tr&gt;</code> contains, among other things, another table of class <code>credit_group</code>, if we open this even further, we get:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img9.png" class="img-fluid figure-img"></p>
<figcaption>Image 9</figcaption>
</figure>
</div>
<p><code>&lt;td&gt;</code> (table data) tags, which contains an <code>&lt;a&gt;</code> (remember, a link) to the movie in question, and within the link is the text that has the movie name which is inside of a <code>&lt;bdi&gt;</code>, which stands for bidirectional isolate. I’m not really sure what that means, but it stores text, and this is the text that we’re interested in order to get the movie name.</p>
</section>
<section id="pseudocode" class="level2">
<h2 class="anchored" data-anchor-id="pseudocode">“Pseudocode”</h2>
<p>So, let’s recap what we need our spider to do:</p>
<ol type="1">
<li>Go to the cast page of our movie.</li>
<li>Iterate through the <code>&lt;li&gt;</code>’s of an <code>&lt;ol&gt;</code>.</li>
<li>For each <code>&lt;li&gt;</code>:
<ol start="4" type="1">
<li>Store the actor’s name from the <code>&lt;a&gt;</code> in each <code>&lt;li&gt;</code>.</li>
<li>Follow the link to the actor’s page</li>
<li>Isolate the correct <code>&lt;table&gt;</code> of class <code>card credits</code></li>
<li>Iterate through the <code>&lt;tr&gt;</code>’s of the <code>&lt;table&gt;</code></li>
<li>For each <code>&lt;table&gt;</code>
<ol start="9" type="1">
<li>Open up the <code>&lt;a&gt;</code> in the <code>credit group</code> table.</li>
<li>Grab the text stored in <code>&lt;bdi&gt;</code></li>
<li>Return a dictionary containing the actor’s name and the movie name</li>
</ol></li>
</ol></li>
</ol>
<p>That’s a lot of steps, but we’ll take them one at a time. Another rule of thumb (whose justification I’ll explain) is that, every time we follow a new link, we need to create a new method for our spider. So, we start on the movie page, go to the cast page, and then go to the actor’s page. Hence, we’ll need 3 different methods which correspond to the (currently blank) ones that you should have in your <code>tmdb_spider.py</code> file.</p>
</section>
<section id="additional-tweaks" class="level2">
<h2 class="anchored" data-anchor-id="additional-tweaks">Additional Tweaks</h2>
<p>There are a few <em>essential</em> things that we should go over before sstarting to play around with our spider, even though we could technically get started right now.</p>
<section id="scrapy-shell" class="level3">
<h3 class="anchored" data-anchor-id="scrapy-shell"><code>scrapy</code> shell</h3>
<p>As it stands, the only way we’re able to test our spider is by imputting commands into our terminal. This makes debugging quite difficult. In order to help with this, it’s recommended that you use the <code>scrapy</code> shell:</p>
<p>https://docs.scrapy.org/en/latest/topics/shell.html</p>
<p>This should be easy to set up if you are working in an envrionment with <code>IPython</code> installed. All you need to do is go to the <code>scrapy.cfg</code> file (which is in the highest level directory within your project folder) and enter the following:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[settings]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ex">shell</span> = ipython</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When you start of the command prompt, this will actually let you simultaneously run <code>scrapy</code> commands while also using it as a Python console, meaning that you can write code.</p>
</section>
<section id="user-agent" class="level3">
<h3 class="anchored" data-anchor-id="user-agent">User Agent</h3>
<p>Websites don’t necessarily like bots on their pages collecting their data all of the time, especially because it can cause a lot of traffic to be directed to a site at once. To mitigate this, many websites have measures that attempt to remove spiders. For example, there is a document called <code>robots.txt</code> that contains information about what webscrapers can and can’t access. By default, there is a line in the <code>settings.py</code> file that displays the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ROBOTSTXT_OBEY <span class="op">=</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It’s important to obey <code>robots.txt</code>, so we’ll be keeping this as-is. However, when I first tried to run my scraper, it didn’t work because I kept getting 403 (access forbidden) errors because the site wasn’t happy about my spider. In order to get around this, we need to mimic a human being on the website. To do so, open <code>settings.py</code> and paste the following:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>USER_AGENT <span class="op">=</span> <span class="st">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I’m not an expert on this, but essentially, the information in <code>USER_AGENT</code> is sent to the website when accessing it, and if we use the <code>USER_AGENT</code> argument to mimic a web browser (I found the above information online), then a website is much more likely to let us through. In my case (and with this website), this solves the issue. Stay in <code>settings.py</code> for the next section!</p>
</section>
<section id="page-limit" class="level3">
<h3 class="anchored" data-anchor-id="page-limit">Page Limit</h3>
<p>While debugging, we don’t want to run extremely long requests since they take time. It’s generally good practice to limit the number of pages that your spider can scrape while you’re still testing it out. In <code>settings.py</code>, paste the following line:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>CLOSESPIDER_PAGECOUNT <span class="op">=</span> <span class="dv">20</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This instructs the spider to terminate its scraping after having visited 20 pages, which is a decent number to start out with, even if (according to the implementation of our spider) we should be visiting more.</p>
<p>Once you’re ready to test your final version, make sure to remove this line!</p>
</section>
</section>
</section>
<section id="spider-methods" class="level1">
<h1>Spider Methods</h1>
<p>Recall that we need to use three different methods for each different page. Returning to our pseudocode steps from earlier, the division of work is going to look something like this:</p>
<ol type="1">
<li>Go to the cast page of our movie. <strong>(Method 1: <code>parse</code>)</strong></li>
<li>Iterate through the <code>&lt;li&gt;</code>’s of an <code>&lt;ol&gt;</code>. <strong>(Method 2: <code>parse_full_credits</code>)</strong></li>
<li>For each <code>&lt;li&gt;</code>:
<ol start="4" type="1">
<li>Store the actor’s name from the <code>&lt;a&gt;</code> in each <code>&lt;li&gt;</code>.</li>
<li>Follow the link to the actor’s page</li>
<li>Isolate the correct <code>&lt;table&gt;</code> of class <code>card credits</code> <strong>(Method 3: <code>parse_actor_page</code>)</strong></li>
<li>Iterate through the <code>&lt;tr&gt;</code>’s of the <code>&lt;table&gt;</code></li>
<li>For each <code>&lt;table&gt;</code>
<ol start="9" type="1">
<li>Open up the <code>&lt;a&gt;</code> in the <code>credit group</code> table.</li>
<li>Grab the text stored in <code>&lt;bdi&gt;</code></li>
<li>Return a dictionary containing the actor’s name and the movie name</li>
</ol></li>
</ol></li>
</ol>
<p>Let’s go through the steps one-by-one for each method.</p>
<section id="method-1-parse" class="level2">
<h2 class="anchored" data-anchor-id="method-1-parse">Method 1: <code>parse</code></h2>
<section id="step-1-go-to-the-cast-page-of-our-movie." class="level3">
<h3 class="anchored" data-anchor-id="step-1-go-to-the-cast-page-of-our-movie.">Step 1: Go to the cast page of our movie.</h3>
<p>The header of our function <code>parse</code> looks like the following:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>parse(<span class="va">self</span>, response)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>response</code> parameter means “whatever it is that our spider is looking at”, i.e., the current page. Thus, the completed version of <code>parse</code> should then be:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(<span class="va">self</span>, response):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Initial parse method for class ```TMdbSpider``</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes valid ``subdir`` argument from initialization.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Sends spider to crawl ``cast_url`` (movie's cast page).</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Yields `scrapy.Request` using `parse_full_credits</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    cast_url <span class="op">=</span> <span class="va">self</span>.start_urls[<span class="dv">0</span>] <span class="op">+</span> <span class="st">"cast"</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> scrapy.Request(cast_url, callback <span class="op">=</span> <span class="va">self</span>.parse_full_credits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The string <code>cast_url</code> simply refers to the step of adding the <code>cast</code> to the end of our movie page’s URL in order to access the cast page. The next line is more complicated. Recall from PIC16A that, for generators, <code>yield</code> acts as a sort of partial return statement that lets the function continue running. When it comes to a <code>scrapy</code> spider, we use <code>yield</code> when we want to jump to another page. We do this by calling the function <code>scrapy.Request</code>, which, for our purposes, has two crucial arguments. One is the url (which we set to <code>cast_url</code>), and the other is called <code>callback</code>. Since <code>yield</code> effectively lets us ‘exit’ the function, we need to specify what method we’re using to crawl through the linked url, which will be the next method, <code>parse_full_credits</code></p>
<p>Upon completing this <code>yield</code>, our spider will then go to the cast page for the actor and access its HTML source code, just like we did when inspecting the page. This is why we need 3 different methods: each page has a different source code, so when we <code>Request</code> something from a new page, we’re looking at something new!</p>
</section>
</section>
<section id="method-2-parse_full_credits" class="level2">
<h2 class="anchored" data-anchor-id="method-2-parse_full_credits">Method 2: <code>parse_full_credits</code></h2>
<section id="step-2-iterate-through-the-lis-of-an-ol." class="level3">
<h3 class="anchored" data-anchor-id="step-2-iterate-through-the-lis-of-an-ol.">Step 2: Iterate through the <code>&lt;li&gt;</code>’s of an <code>&lt;ol&gt;</code>.</h3>
<p>Okay, so now that our spider is on the page <code>cast_url</code>, we need to tell it what to do on that page, and because of our <code>callback</code> argument, we’re going to need to write code for the <code>parse_full_credits</code> method.</p>
<p>So, remember that the first thing that we wanted our spider to do was to inspect the <code>&lt;ol&gt;</code> of class <code>people credits</code>. If you go to the page in question, we will see that these are properly kept as <code>ol.people.credits</code>. There’s one other caveat. We have to make sure that we’re only grabbing actors and not any other crew members. Luckily, the credits for crew members are stored in a class called <code>ol.people.credits.crew</code>, but if we were to just specify <code>ol.people.credits</code> in our code, <code>scrapy</code> will only check whether or not that tag/class is contained in the class that it’s inspecting, not if they’re identical. So, to navigate to just hte normal <code>ol.people.credits</code>, we need our spider to go to <code>ol.people.credits:not(.crew)</code>. Furthermore, we don’t want our spider to grab every single piece of information within the <code>ol</code>, but rather, each of the <code>li</code>s. To specify that we’re looking for a tag witihn a tag, we put a space after our query and type the name of the tag we’re interested in. Hence, we want our spider to go to <code>ol.people.credits:not(.crew) li</code>, for each <code>li</code>. Finally, remember how there were 2 different links inside of each <code>li</code>, but we only wanted one of them? The one that wasn’t stored with the actor’s photo was in a <code>&lt;div&gt;</code> of class <code>info</code>. So, our final “query” is going to be <code>ol.people.credits:not(.crew) li div.info</code></p>
<p>Alright, how do we actually do this? This involves using the <code>response</code> parameter from earlier. Recall that <code>response</code> is the HTML source code. By using the <code>.css</code> method, we can essentially sort through the page’s CSS code to convert what’s on the page into something that <code>tmdb_spider.py</code> can process. Hence, for now, write the following:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response): </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    actor_list <span class="op">=</span> response.css(<span class="st">"ol.people.credits:not(.crew) li div.info"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One very nice thing about the way <code>.css</code> works is that our spider will automatically grab <em>every</em> instance of <code>li</code> that matches the above criteria. We don’t have to worry about any sort of iteration at this point. In fact, the return value, which we store as <code>actor_list</code> is an iterator that we can use with a <code>for</code> loop! Note that anything inside of <code>.css</code> must be a string.</p>
</section>
<section id="step-3-for-each-li" class="level3">
<h3 class="anchored" data-anchor-id="step-3-for-each-li">Step 3: For each <code>&lt;li&gt;</code></h3>
<section id="store-the-actors-name-from-the-a-in-each-li." class="level4">
<h4 class="anchored" data-anchor-id="store-the-actors-name-from-the-a-in-each-li.">Store the actor’s name from the <code>&lt;a&gt;</code> in each <code>&lt;li&gt;</code>.</h4>
<p>Recall that the both the actor’s name and the link to their page is stored within each <code>&lt;li&gt;</code>. Thus, we can make our <code>for</code> loop as such:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response): </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    actor_list <span class="op">=</span> response.css(<span class="st">"ol.people.credits:not(.crew) li div.info"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> actor_li <span class="kw">in</span> actor_list:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        actor_name <span class="op">=</span> actor_li.css(<span class="st">"a::text"</span>).get()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since <code>actor_list</code> is an iterator, we can call its individual elements <code>actor_li</code>, which is still a piece of HTML source code that we’ve placed locally into our program. So, once again, we inspect the <code>&lt;li&gt;</code>’s CSS code by using <code>.css</code>. In particular, recall that links are stored in a tag called <code>&lt;a&gt;</code>, but <code>&lt;a&gt;</code>’s contain multiple parts that aren’t necessarily subtags. In these cases, we use the double colon operator <code>::</code> to grab specific parts of the tag. The name of the actor, if you go back to the screenshot above, was not kept in any sort of specific attribute. Rather, it was just placed in the body of <code>&lt;a&gt;</code>. We can access it by calling <code>a::text</code>. To convert that text into a Python string, however, we need to use the <code>.get()</code> method, which we then assign to <code>actor_name</code>.</p>
<p>One tricky bit here, by the way, is that while <code>response.css</code> grabs every instance of the specified tag, <code>.get()</code> will only place the first instance of what’s found into a Python object. This doesn’t matter in this specific instance, but it’s important to know. You would have to use <code>.getall()</code> otherwise.</p>
</section>
<section id="follow-the-link-to-the-actors-page" class="level4">
<h4 class="anchored" data-anchor-id="follow-the-link-to-the-actors-page">Follow the link to the actor’s page</h4>
<p>The completed <code>for</code> loop below is longer than you might be expecting:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response): </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Second parse method for class ``TMdbSpider``</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Called from `parse`. Assumes valid ``cast_url``</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Fetches links to all actors' pages from cast page:</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">    An ordered list `ol` of class `people credits` contains</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">    `li` list elements with `div` elements of class `info`.</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Each `li` stores the link to the actor's page and the</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    actor's name in an `a` tag.</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Stores name of each actor in ``actor_name``.</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Yields `scrapy.Request` using `self.parse_actor_page`. Passes ``actor_name``</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    actor_list <span class="op">=</span> response.css(<span class="st">"ol.people.credits:not(.crew) li div.info"</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> actor_li <span class="kw">in</span> actor_list:</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        actor_link <span class="op">=</span> actor_li.css(<span class="st">"a::attr(href)"</span>).get()</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        actor_name <span class="op">=</span> actor_li.css(<span class="st">"a::text"</span>).get()</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> actor_link:</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>            actor_link <span class="op">=</span> response.urljoin(actor_link)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> scrapy.Request(actor_link, callback<span class="op">=</span><span class="va">self</span>.parse_actor_page, meta <span class="op">=</span> {<span class="st">"actor"</span>: actor_name})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In addition to grabbing the actor’s name, as we just did, we also grab the link and store it as a string in <code>actor_link</code>, once again using <code>.get()</code>. This time, <code>href</code> is stored as an attribute of <code>&lt;a&gt;</code> (note that it’s in pink when we inspect the page), so we use <code>a::attr(href)</code>. If you remember from earlier, though, what’s stored inside of <code>href</code> is not the full URL, it’s just a subdirectory on <code>https://www.themoviedb.org</code>. We then have a conditional statement <code>if actor_link</code>. Recall that <code>actor_link</code> is a string. We want to make sure to stop here if we’ve gotten to the last actor on the page, so if there’s no one left, <code>actor_link</code> will simply be set to <code>None</code>. If we do have a link present, however, we can easily convert it to the full URL, however, by using the <code>.urljoin</code> method of <code>response</code>. This takes the root of the <code>response</code> webpage and simply adds whatever subdirectory is specified.</p>
<p>Since we’re going to be navigating to another page, we’re going to have to call <code>scrapy.Request</code> again. The next URL is <code>actor_link</code>, our last method will be <code>parse_actor_page</code>, but we also pass in a dictionary called <code>meta</code> with key <code>actor</code> and value <code>actor_name</code>. Parse methods in <code>scrapy</code> have the ability to allow for optional arguments (<code>**kwargs</code>) which we need if we want to pass the actor’s name from this method to the next one. To find out about this, I read this page. Search for “meta”:</p>
<p>https://docs.scrapy.org/en/latest/topics/request-response.html</p>
<p>Note that we can’t just declare a new instance variable called <code>actor_name</code> or something like that. This ends up breaking the code.</p>
</section>
</section>
</section>
<section id="method-3-parse_actor_page" class="level2">
<h2 class="anchored" data-anchor-id="method-3-parse_actor_page">Method 3: <code>parse_actor_page</code></h2>
<p>Now we’re onto the last page, and the last method!</p>
<section id="step-4-isolate-the-correct-table-of-class-card-credits" class="level3">
<h3 class="anchored" data-anchor-id="step-4-isolate-the-correct-table-of-class-card-credits">Step 4: Isolate the correct <code>&lt;table&gt;</code> of class <code>card credits</code></h3>
<p>Just like we did with the <code>&lt;ol&gt;</code> in the previous method, we’re going to use <code>response.css</code> to grab the <code>card credits</code> table that has the acting appearances and store it as an iterator that we will extract individual movies from. But remember what we said earlier? We only want to grab the <em>first</em> table of this type, so we’re going to be using a single colon with <code>:first-of-type</code> (thank you Professor Ko for helping me with this!). and grab all of the <code>tooltip</code> classes of <code>&lt;a&gt;</code>, which are precisely the actor names (see images from the previous part:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    movie_list <span class="op">=</span> response.css(<span class="st">"div.credits_list table.card.credits:first-of-type a.tooltip"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>…Except this doesn’t completely work. The problem (which I discovered when testing my submission for this assignment) is that there are some actors for whom the table that shows the movies in which they’ve acted is <em>not</em> the first. This seems to happen when someone is primarily known as a crew member but has also made appearances in movies–the works in which they’ve been a crew member appear at the top.</p>
<p>There is, however, a fix. Look at the image below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HW2Img10.png" class="img-fluid figure-img"></p>
<figcaption>Image 10</figcaption>
</figure>
</div>
<p>Each of the tables is preceded by a tag <code>&lt;h3&gt;</code> (which is a sort of header) that acts as a label. In our case, we want the table that follows the <code>&lt;h3&gt;</code> tag with text “Acting.” How do we do this? I wasn’t very sure because up until now, all we’ve had to do is filter <em>within</em> certain tags–I had to figure out how to access items based on <em>surrounding</em> tags.</p>
<p>I’m not sure if this is possible using the <code>.css</code> method, but I did find that through <code>xpath</code>, this is possible via this StackOverflow post:</p>
<p>https://stackoverflow.com/questions/65271036/python-scrapy-selector-for-text-elements-between-tags</p>
<p><code>xpath</code> is a language designed to parse through <code>xml</code> documents, which is similar to HTML. I’m not exactly how XML differs from HTML, nor do I know about how compatible they are. What I do know is that we can use it with Scrapy, and there is documentation about this on scrapy’s selector page:</p>
<p>https://docs.scrapy.org/en/latest/topics/selectors.html#scrapy.selector.Selector</p>
<p>I was able to get a grasp on how to use it from both the StackOverflow post, the site below, and the blog post below:</p>
<p>https://www.w3schools.com/xml/xpath_syntax.asp https://www.guru99.com/using-contains-sbiling-ancestor-to-find-element-in-selenium.html</p>
<p>The command we need to input is the following:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>acting_table <span class="op">=</span> response.xpath(<span class="st">"//h3[contains(text(), 'Acting')]/following-sibling::table[@class='card credits'][1]"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a> movie_list <span class="op">=</span> acting_table.css(<span class="st">"a.tooltip"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>response.xpath</code> is used when we want to use XPath instead of HTML. The double slash <code>//</code> is similar to typing the name of a tag with <code>.css</code>. What follows is the name of the tag that we’re interested in, so in our case, we use <code>h3</code>. The brackets are used to place some sort of function inside. We use one called <code>contains</code> which is a sort of filtering function which, for our purposes, takes two arguments. The first lets us know what kind of item we’re looking for, in our case, <code>text()</code>, and the second is the thing itself we want, namely, <code>Acting</code>. So, once we wrap this up, we get all <code>&lt;h3&gt;</code>s such that they contain the word <code>Acting</code>.</p>
<p>But, remember, that’s not what we want. We want the table of class <code>card credits</code> that follows the table. This is where we really need <code>xpath</code>, because we get to use something called <code>following-sibling</code>. First, though, we have to put a single slash <code>/</code>. This is what’s used to select from a prior node (whereas the double slash is used to select everything corresponding to a specific tag). <code>following-sibling</code> can be used to select items that are siblings “on the same level,” in a certain sense. Notice how the <code>&lt;table&gt;</code>‘s are interlaced by the <code>&lt;h3&gt;</code>’s–one isn’t a subtag of the other, so they’re siblings! According to the syntax, we have to specify what kind of tag we want with the double colon operator, so <code>::table</code>, and then we specify the class within brackets with <code>@class = 'card credits'</code>. We put a <code>[1]</code> at the end (<code>xpath</code> indexing sadly starts from 1) to specify that we only want the first of such tables (since otherwise we’d be grabbing <em>all</em> of them that following ’Acting’.</p>
<p>Then I return back to CSS just to be more comfortable. We grab all of the <code>tooltip</code>s in <code>&lt;a&gt;</code> to get the movie names.</p>
<section id="grab-the-text-stored-in-bdi" class="level4">
<h4 class="anchored" data-anchor-id="grab-the-text-stored-in-bdi">Grab the text stored in <code>&lt;bdi&gt;</code></h4>
<p>Now, like we did earlier, we need to create a <code>for</code> loop. Recall that the name of the movie that the actor has starred in is stored in a <code>&lt;bdi&gt;</code>, so we once again need to use the double colon operator with <code>text</code> in order to select the name. Finally, we use the <code>.get()</code> method to store it as a string.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>acting_table <span class="op">=</span> response.xpath(<span class="st">"//h3[contains(text(), 'Acting')]/following-sibling::table[@class='card credits'][1]"</span>) </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        movie_list <span class="op">=</span> acting_table.css(<span class="st">"a.tooltip"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> movie <span class="kw">in</span> movie_list:</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>            movie_or_TV_name <span class="op">=</span> movie.css(<span class="st">"bdi::text"</span>).get()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="return-a-dictionary-containing-the-actors-name-and-the-movie-name" class="level4">
<h4 class="anchored" data-anchor-id="return-a-dictionary-containing-the-actors-name-and-the-movie-name">Return a dictionary containing the actor’s name and the movie name</h4>
<p>This is the last step! We’ll actually do this in the body of a <code>yield</code> statement, which will signal to <code>scrapy</code> that this is the end (no more requests after this). Of course, by virtue of the fact that we’ve been using <code>yield</code>s (and not <code>returns</code>) this whole time allows us to continue iterating in our <code>for</code> loop (we do, after all, technically have a nested <code>for</code> loop split across two methods).</p>
<p>See the code below:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Final parse method for class ``TMdbSpider``</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Called from `parse_full_credits`. Assumes valid ``actor_link`` and ``actor_name``</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Fetches the name of each movie that an actor has been in from their page. Each</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">    movie's name is in the text component of a `bdi` element on the page. The `bdi`</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">    element is in a link (`a`) element of class `tooltip`.</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Yields the actor's name and each movie/TV show's name as a dictionary with keys</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    "actor" and "movie_or_TV_name"</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Actor name  takenfrom ``actor`` key in dict ``meta``, extracted from</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">    `parse_full credits`.</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    acting_table <span class="op">=</span> response.xpath(<span class="st">"//h3[contains(text(), 'Acting')]/following-sibling::table[@class='card credits'][1]"</span>) <span class="co">#Grabs the first table following 'Acting'</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        movie_list <span class="op">=</span> acting_table.css(<span class="st">"a.tooltip"</span>)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">#Get only the films/shows they've appeared in, and grab their link tooltips</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> movie <span class="kw">in</span> movie_list:</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>            movie_or_TV_name <span class="op">=</span> movie.css(<span class="st">"bdi::text"</span>).get() <span class="co">#Get the name in &lt;bdi&gt; from each movie</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> {</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>            <span class="st">"actor"</span> : response.meta.get(<span class="st">"actor"</span>), <span class="co">#Actor name passed into function</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>            <span class="st">"movie_or_TV_name"</span> : movie_or_TV_name <span class="co">#From above result</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>                }              </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>movie_or_TV_name</code> was stored for us in the last step, but recall that we passed the actor name into <code>parse_actor_page</code> using <code>kwargs**</code>. Per the documentation, we have to use the method <code>.meta.get()</code> on the dictionary key in order to get its corresponding value (recall that we had <code>meta = {"actor" : actor_name}</code>).</p>
<p>And then we’re done! Well, with making the spider, anyway.</p>
</section>
</section>
</section>
</section>
<section id="getting-results" class="level1">
<h1>Getting Results</h1>
<p>Now the time has come to actually run our spider. Make sure to remove the <code>CLOSESPIDER_PAGECOUNT = 20</code> line from <code>settings.py</code> and that your current directory is set to the project folder. The following command should generate a <code>.csv</code> file called <code>movies</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">scrapy</span> crawl tmdb_spider <span class="at">-o</span> movies.csv <span class="at">-a</span> subdir=137113-edge-of-tomorrow</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>crawl</code> command lets <code>scrapy</code> know that we’re going to be using our spider to crawl. We then follow it with the name of the spider (the <code>name</code> variable in the class initialization). <code>-o</code> lets the command line know the format of our output, in this case, a <code>csv</code> file called <code>movies</code>. Note that if we replace this with a capital <code>-O</code>, we’ll rewrite the file (otherwise we would add onto it). If you want to be testing with the same file, it’s probably a good idea to write over the file.</p>
<p><code>-a</code> signals that whatever comes afterwards is an argument of our spider. In thiscase, the <code>subdir</code> for Edge of Tomorrow’s movie page.</p>
<p>Let’s import this file into our notebook to see what we’ve gotten!</p>
<div id="99e4c3d5" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>movies <span class="op">=</span> pd.read_csv(<span class="st">"movies.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9e23d074" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>movies.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">movie_or_TV_name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Dany Cushmaro</td>
<td>Edge of Tomorrow</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Erin Burnett</td>
<td>Edge of Tomorrow</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Erin Burnett</td>
<td>The Incredible Burt Wonderstone</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Erin Burnett</td>
<td>Erin Burnett OutFront</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Erin Burnett</td>
<td>Too Big to Fail</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="d2e6d3b3" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>movies.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1207 entries, 0 to 1206
Data columns (total 2 columns):
 #   Column            Non-Null Count  Dtype 
---  ------            --------------  ----- 
 0   actor             1207 non-null   object
 1   movie_or_TV_name  1207 non-null   object
dtypes: object(2)
memory usage: 19.0+ KB</code></pre>
</div>
</div>
<p>1207 movies (or shows)! That’s quite a lot. Let’s see who appears in the most movies:</p>
<div id="947923f7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>movies_manip <span class="op">=</span> movies.copy()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>appearances <span class="op">=</span> movies_manip.groupby(<span class="st">"actor"</span>).<span class="bu">apply</span>(<span class="st">"count"</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>appearances <span class="op">=</span> appearances.reset_index().sort_values(by <span class="op">=</span> <span class="st">"movie_or_TV_name"</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>          ascending <span class="op">=</span> <span class="va">False</span>).rename(columns <span class="op">=</span> {<span class="st">"movie_or_TV_name"</span> :<span class="st">"count"</span>})</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>appearances[<span class="st">'Sole Appearance'</span>] <span class="op">=</span> appearances[<span class="st">'count'</span>] <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>appearances.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">count</th>
<th data-quarto-table-cell-role="th">Sole Appearance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">34</td>
<td>Tom Cruise</td>
<td>128</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">10</td>
<td>David Kaye</td>
<td>116</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>Bill Paxton</td>
<td>107</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>Brendan Gleeson</td>
<td>104</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">12</td>
<td>Emily Blunt</td>
<td>103</td>
<td>False</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Tom Cruise sure is an accomplished actor, and there are some others who are pretty close to him! Let’s take a look and see in more detail:</p>
<div id="1edca67c" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.io <span class="im">as</span> pio</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>pio.renderers.default<span class="op">=</span><span class="st">"iframe"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="bdc10217" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> plotly <span class="im">import</span> express <span class="im">as</span> px</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>movie_bar <span class="op">=</span> px.bar(appearances, x<span class="op">=</span><span class="st">"actor"</span>, y <span class="op">=</span> <span class="st">"count"</span>, color <span class="op">=</span> <span class="st">"Sole Appearance"</span>, color_discrete_sequence<span class="op">=</span>[<span class="st">'blue'</span>, <span class="st">'red'</span>])</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>movie_bar.update_layout(</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="bu">dict</span>(text<span class="op">=</span><span class="st">"Appearances per Actor"</span>, font<span class="op">=</span><span class="bu">dict</span>(size<span class="op">=</span><span class="dv">20</span>), automargin<span class="op">=</span><span class="va">True</span>, yref<span class="op">=</span><span class="st">'paper'</span>),</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    xaxis_title<span class="op">=</span><span class="st">""</span>,</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    yaxis_title<span class="op">=</span><span class="st">"Number of Appearances"</span>,</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<iframe scrolling="no" width="100%" height="545px" src="iframe_figures/figure_6.html" frameborder="0" allowfullscreen=""></iframe>
</div>
</div>
<p>There are actually 4 actors that have only ever appeared in Edge of Tomorrow! According to the TMDB database, John Dutton played someone named ‘Old Man 2’, Darry Cushmaro was ‘Channel 2 News Anchor’, Aaron Romano was ‘Dog Soldier 2’ (but a human), but Jackson was ’Refugee Dog! :)</p>
<p>It would also be interesting to see what other movies have featured the highest number of the same actors:</p>
<div id="dd04beff" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>coincidences <span class="op">=</span> movies.copy()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>coincidences[<span class="st">'Movies Together'</span>] <span class="op">=</span> coincidences.groupby(<span class="st">"movie_or_TV_name"</span>).transform(<span class="st">"count"</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>coincidences <span class="op">=</span> coincidences[(coincidences[<span class="st">'Movies Together'</span>] <span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">&amp;</span> (coincidences[<span class="st">'movie_or_TV_name'</span>] <span class="op">!=</span> <span class="st">'Edge of Tomorrow'</span>)]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>coincidences <span class="op">=</span> coincidences.sort_values(by <span class="op">=</span> <span class="st">"Movies Together"</span>, ascending <span class="op">=</span> <span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fe4f5fc5" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>coincidences</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">movie_or_TV_name</th>
<th data-quarto-table-cell-role="th">Movies Together</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">619</td>
<td>Tony Way</td>
<td>Doctor Who</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">483</td>
<td>Ronan Summers</td>
<td>Doctor Who</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">362</td>
<td>Tommy Campbell</td>
<td>Doctor Who</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">455</td>
<td>Bentley Kalu</td>
<td>Doctor Who</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">537</td>
<td>Beth Goddard</td>
<td>Casualty</td>
<td>3</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">459</td>
<td>Ronan Summers</td>
<td>Hitmen</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">454</td>
<td>Bentley Kalu</td>
<td>Gulliver's Travels</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">453</td>
<td>Bentley Kalu</td>
<td>Twenty Twelve</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">442</td>
<td>Bentley Kalu</td>
<td>American Assassin</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1206</td>
<td>Emily Blunt</td>
<td>The Oscars</td>
<td>2</td>
</tr>
</tbody>
</table>

<p>131 rows × 3 columns</p>
</div>
</div>
</div>
<p>Besides Edge of Tomorrow, the most common works that people have in common are TV shows, which isn’t surprising, since they have lots of episodes. 4 of our actors have been in Doctor Who together. Let’s see what else we’ve got:</p>
<div id="f644225d" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>coincidences_bar <span class="op">=</span> px.bar(coincidences, x<span class="op">=</span><span class="st">"movie_or_TV_name"</span>, hover_name <span class="op">=</span> <span class="st">'actor'</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>coincidences_bar.update_layout(</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="bu">dict</span>(text<span class="op">=</span><span class="st">"Other Shared Works (Hover to See Names)"</span>, font<span class="op">=</span><span class="bu">dict</span>(size<span class="op">=</span><span class="dv">20</span>), automargin<span class="op">=</span><span class="va">True</span>, yref<span class="op">=</span><span class="st">'paper'</span>),</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    xaxis_title<span class="op">=</span><span class="st">""</span>,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    yaxis_title<span class="op">=</span><span class="st">"Number of Shared Actors"</span>,</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>coincidences_bar.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<iframe scrolling="no" width="100%" height="545px" src="iframe_figures/figure_10.html" frameborder="0" allowfullscreen=""></iframe>
</div>
</div>
<p>It’s also not surprising to see talk shows like Saturday Night Live, The View, and the Graham Norton Show being futured. Doctor Who, Green Zone, and Sherlock are the only other fictional works that have at least 3 actors in common, and Green Zone is the only movie. Maybe I’ll like that one too!</p>
</section>
<section id="thanks-for-reading-my-post-3" class="level1">
<h1>Thanks for reading my post :3</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://pusheen.com/wp-content/uploads/2023/11/Capybar_Hot_Springs_GIF.gif" class="img-fluid figure-img"></p>
<figcaption>Pusheen in the Tub</figcaption>
</figure>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>